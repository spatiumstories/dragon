"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Social = void 0;
const tslib_1 = require("tslib");
const axios_1 = (0, tslib_1.__importDefault)(require("axios"));
class Social {
    constructor(node, identity, user) {
        this.sendMessageWithoutIdentity = async (
        // TODO: temp fix method until major library update
        request) => {
            return (await axios_1.default.post(`${this.node.getUri()}/send-message-stateless`, request)).data;
        };
        this.user = user;
        this.node = node;
        this.identity = identity;
    }
    async sendMessage(request, options) {
        const encryptedMessage = await this.identity.encrypt(request);
        request.EncryptedMessageText = encryptedMessage;
        if (!request.MinFeeRateNanosPerKB) {
            request.MinFeeRateNanosPerKB = 1000;
        }
        const response = (await axios_1.default.post(`${this.node.getUri()}/send-message-stateless`, request)).data;
        return await this.identity.submitTransaction(response.TransactionHex, options);
    }
    async createFollowTxnStateless(request, options) {
        if (!request.FollowerPublicKeyBase58Check) {
            throw Error('FollowerPublicKeyBase58Check is undefined');
        }
        if (!request.FollowedPublicKeyBase58Check) {
            throw Error('FollowedPublicKeyBase58Check is undefined');
        }
        if (request.IsUnfollow instanceof Boolean) {
            throw Error('IsUnfollow is undefined');
        }
        request = { ...{ MinFeeRateNanosPerKB: 1000 }, ...request };
        const response = (await axios_1.default.post(`${this.node.getUri()}/create-follow-txn-stateless`, request)).data;
        return await this.identity.submitTransaction(response.TransactionHex, options);
    }
    async getFollowsStateless(request) {
        const endpoint = 'get-follows-stateless';
        const response = (await axios_1.default.post(`${this.node.getUri()}/${endpoint}`, request)).data;
        return response;
    }
    async getMessagesStatelessV3(request) {
        const response = (await axios_1.default.post(`${this.node.getUri()}/get-messages-stateless`, request)).data;
        return response;
    }
    async getMessagesStateless(request) {
        const response = (await axios_1.default.post(`${this.node.getUri()}/get-messages-stateless`, request)).data;
        const encryptedMessages = response.OrderedContactsWithMessages
            .map((thread) => {
            if (thread.Messages === null) {
                return [];
            }
            return thread.Messages.map((message) => ({
                EncryptedHex: message.EncryptedText,
                PublicKey: message.IsSender
                    ? message.RecipientPublicKeyBase58Check
                    : message.SenderPublicKeyBase58Check,
                IsSender: message.IsSender,
                Legacy: !message.V2 && (!message.Version || message.Version < 2),
                Version: message.Version,
                SenderMessagingPublicKey: message.SenderMessagingPublicKey,
                SenderMessagingGroupKeyName: message.SenderMessagingGroupKeyName,
                RecipientMessagingPublicKey: message.RecipientMessagingPublicKey,
                RecipientMessagingGroupKeyName: message.RecipientMessagingGroupKeyName,
            }));
        })
            .flat();
        return this.identity.decrypt(encryptedMessages);
    }
    async getHodlersForPublicKey(request) {
        const endpoint = 'get-hodlers-for-public-key';
        return await axios_1.default.post(`${this.node.getUri()}/${endpoint}`, request);
    }
    async getDiamondsForPublicKey(request) {
        const endpoint = 'get-diamonds-for-public-key';
        return await axios_1.default.post(`${this.node.getUri()}/${endpoint}`, request);
    }
    async isFollowingPublicKey(request) {
        const endpoint = 'is-following-public-key';
        return await axios_1.default.post(`${this.node.getUri()}/${endpoint}`, request);
    }
    async isHodlingPublicKey(request) {
        const endpoint = 'is-hodling-public-key';
        return await axios_1.default.post(`${this.node.getUri()}/${endpoint}`, request);
    }
    async updateProfile(request, options) {
        const endpoint = 'update-profile';
        const response = (await axios_1.default.post(`${this.node.getUri()}/${endpoint}`, request)).data;
        return await this.identity
            .submitTransaction(response.TransactionHex, options)
            .then(() => response)
            .catch(() => {
            throw Error('something went wrong while signing');
        });
    }
    async sendDiamonds(request, options) {
        const endpoint = 'send-diamonds';
        const response = (await axios_1.default.post(`${this.node.getUri()}/${endpoint}`, request)).data;
        return await this.identity
            .submitTransaction(response.TransactionHex, options)
            .then(() => response)
            .catch(() => {
            throw Error('something went wrong while signing');
        });
    }
    async createLikeStateless(request, options) {
        const endpoint = 'create-like-stateless';
        const response = await (await axios_1.default.post(`${this.node.getUri()}/${endpoint}`, request)).data;
        return await this.identity
            .submitTransaction(response.TransactionHex, options)
            .then(() => response)
            .catch(() => {
            throw Error('something went wrong while signing');
        });
    }
    async checkPartyMessagingKey(request) {
        const endpoint = 'check-party-messaging-keys';
        const response = await (await axios_1.default.post(`${this.node.getUri()}/${endpoint}`, request)).data;
        return response;
    }
}
exports.Social = Social;
//# sourceMappingURL=Social.js.map