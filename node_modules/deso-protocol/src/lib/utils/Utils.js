"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decrypt = exports.decryptShared = exports.decryptMessageFromPrivateMessagingKey = exports.decryptMessage = exports.encrypt = exports.getPublic = exports.kdf = exports.derive = exports.encryptShared = exports.encryptMessageFromPrivateMessagingKey = exports.encryptMessage = exports.signTransaction = exports.seedHexToPrivateKey = exports.seedHexToECKeyPair = exports.publicKeyToDeSoPublicKey = exports.privateKeyToDeSoPublicKey = exports.getMetaMaskMasterPublicKeyFromSignature = exports.desoAddressToECKeyPair = exports.PUBLIC_KEY_PREFIXES = exports.signMessageLocally = exports.generateKey = exports.privateKeyToSeedHex = exports.generateKeyFromSource = exports.generateKeyFromSeedHex = exports.keychainToSeedHex = exports.uvarint64ToBuf = exports.uint64ToBufBigEndian = void 0;
const tslib_1 = require("tslib");
const bip39 = (0, tslib_1.__importStar)(require("bip39"));
const sha256 = (0, tslib_1.__importStar)(require("sha256"));
const bs58check = (0, tslib_1.__importStar)(require("bs58check"));
const crypto_1 = require("crypto");
const elliptic_1 = require("elliptic");
const hdkey_1 = (0, tslib_1.__importDefault)(require("hdkey"));
const elliptic_2 = require("elliptic");
const ethers_1 = require("ethers");
const uint64ToBufBigEndian = (uint) => {
    const result = [];
    while (BigInt(uint) >= BigInt(0xff)) {
        result.push(Number(BigInt(uint) & BigInt(0xff)));
        uint = Number(BigInt(uint) >> BigInt(8));
    }
    result.push(Number(BigInt(uint) | BigInt(0)));
    while (result.length < 8) {
        result.push(0);
    }
    return new Buffer(result.reverse());
};
exports.uint64ToBufBigEndian = uint64ToBufBigEndian;
const uvarint64ToBuf = (uint) => {
    const result = [];
    while (uint >= 0x80) {
        result.push(Number((BigInt(uint) & BigInt(0xff)) | BigInt(0x80)));
        uint = Number(BigInt(uint) >> BigInt(7));
    }
    result.push(uint | 0);
    return Buffer.from(result);
};
exports.uvarint64ToBuf = uvarint64ToBuf;
const keychainToSeedHex = (keychain) => {
    return keychain.privateKey.toString('hex');
};
exports.keychainToSeedHex = keychainToSeedHex;
const generateKeyFromSeedHex = ({ seedHex }) => {
    const ec = new elliptic_1.ec('secp256k1');
    return ec.keyFromPrivate(seedHex);
};
exports.generateKeyFromSeedHex = generateKeyFromSeedHex;
const generateKeyFromSource = ({ mnemonic, extraText = '', nonStandard = true, }) => {
    const ec = new elliptic_1.ec('secp256k1');
    const seed = bip39.mnemonicToSeedSync(mnemonic, extraText);
    const hdKey = hdkey_1.default.fromMasterSeed(seed).derive("m/44'/0'/0'/0/0", 
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    nonStandard);
    const seedHex = hdKey.privateKey.toString('hex');
    return ec.keyFromPrivate(seedHex);
};
exports.generateKeyFromSource = generateKeyFromSource;
const privateKeyToSeedHex = (privateKey) => {
    const privateKeyBuffer = Buffer.from(privateKey, 'hex');
    const hdKey = hdkey_1.default.fromMasterSeed(privateKeyBuffer);
    return hdKey.privateKey.toString('hex');
};
exports.privateKeyToSeedHex = privateKeyToSeedHex;
/**
 * @returns publicKeyBase58Check Base58 encoded public key
 * @returns keyPair object for signing
 * Generates a new derived key
 */
const generateKey = async (network = 'mainnet') => {
    const e = new elliptic_2.ec('secp256k1');
    const entropy = ethers_1.ethers.utils.randomBytes(16);
    const dMnemonic = ethers_1.ethers.utils.entropyToMnemonic(entropy);
    const dKeyChain = ethers_1.ethers.utils.HDNode.fromMnemonic(dMnemonic);
    const prefix = exports.PUBLIC_KEY_PREFIXES[network].deso;
    const keyPair = e.keyFromPrivate(dKeyChain.privateKey); // gives us the keypair
    const seedHex = (0, exports.privateKeyToSeedHex)(dKeyChain.privateKey);
    const desoKey = keyPair.getPublic().encode('array', true);
    const prefixAndKey = Uint8Array.from([...prefix, ...desoKey]);
    const publicKeyBase58Check = bs58check.encode(prefixAndKey);
    return { publicKeyBase58Check, keyPair, seedHex };
};
exports.generateKey = generateKey;
/**
 *
 * @param transactionHex transaction representation from the construction endpoint
 * @param keyPair EC key object used to sign the transaction
 * @returns signed transaction bytes that can be submitted to the submitTransaction endpoint
 */
const signMessageLocally = ({ transactionHex, keyPair, }) => {
    const transactionBytes = new Buffer(transactionHex, 'hex');
    const transactionHash = new Buffer(sha256.x2(transactionBytes), 'hex');
    const sig = keyPair.sign(transactionHash);
    const signatureBytes = new Buffer(sig.toDER());
    const signatureLength = (0, exports.uvarint64ToBuf)(signatureBytes.length);
    const signedTransactionBytes = Buffer.concat([
        transactionBytes.slice(0, -1),
        signatureLength,
        signatureBytes,
    ]);
    return signedTransactionBytes.toString('hex');
};
exports.signMessageLocally = signMessageLocally;
exports.PUBLIC_KEY_PREFIXES = {
    mainnet: {
        bitcoin: [0x00],
        deso: [0xcd, 0x14, 0x0],
    },
    testnet: {
        bitcoin: [0x6f],
        deso: [0x11, 0xc2, 0x0],
    },
};
const desoAddressToECKeyPair = (publicKey) => {
    if (publicKey.length < 5) {
        throw new Error('Failed to decode public key');
    }
    const decoded = bs58check.decode(publicKey);
    const payload = Uint8Array.from(decoded).slice(3);
    const e = new elliptic_2.ec('secp256k1');
    return e.keyFromPublic(payload, 'array');
};
exports.desoAddressToECKeyPair = desoAddressToECKeyPair;
const getMetaMaskMasterPublicKeyFromSignature = (signature, message, network = 'mainnet') => {
    const e = new elliptic_2.ec('secp256k1');
    const arrayify = ethers_1.ethers.utils.arrayify;
    const messageHash = arrayify(ethers_1.ethers.utils.hashMessage(message));
    const publicKeyUncompressedHexWith0x = ethers_1.ethers.utils.recoverPublicKey(messageHash, signature);
    const messagingPublicKey = e.keyFromPublic(publicKeyUncompressedHexWith0x.slice(2), 'hex');
    const prefix = exports.PUBLIC_KEY_PREFIXES[network].deso;
    const key = messagingPublicKey.getPublic().encode('array', true);
    const desoKey = Uint8Array.from([...prefix, ...key]);
    const encodedDesoKey = bs58check.encode(desoKey);
    return encodedDesoKey;
};
exports.getMetaMaskMasterPublicKeyFromSignature = getMetaMaskMasterPublicKeyFromSignature;
const privateKeyToDeSoPublicKey = (privateKey, network = 'mainnet') => {
    const prefix = exports.PUBLIC_KEY_PREFIXES[network].deso;
    const key = privateKey.getPublic().encode('array', true);
    const prefixAndKey = Uint8Array.from([...prefix, ...key]);
    return bs58check.encode(prefixAndKey);
};
exports.privateKeyToDeSoPublicKey = privateKeyToDeSoPublicKey;
const publicKeyToDeSoPublicKey = (publicKey, network = 'mainnet') => {
    const prefix = exports.PUBLIC_KEY_PREFIXES[network].deso;
    const key = publicKey.getPublic().encode('array', true);
    return bs58check.encode(Buffer.from([...prefix, ...key]));
};
exports.publicKeyToDeSoPublicKey = publicKeyToDeSoPublicKey;
function seedHexToECKeyPair(seedHex) {
    const ec = new elliptic_1.ec('secp256k1');
    return ec.keyFromPrivate(seedHex);
}
exports.seedHexToECKeyPair = seedHexToECKeyPair;
const seedHexToPrivateKey = (seedHex) => {
    const ec = new elliptic_1.ec('secp256k1');
    return ec.keyFromPrivate(seedHex);
};
exports.seedHexToPrivateKey = seedHexToPrivateKey;
const signTransaction = (seedHex, transactionHex, isDerivedKey) => {
    const privateKey = (0, exports.seedHexToPrivateKey)(seedHex);
    const transactionBytes = new Buffer(transactionHex, 'hex');
    const transactionHash = new Buffer(sha256.x2(transactionBytes), 'hex');
    const signature = privateKey.sign(transactionHash, { canonical: true });
    const signatureBytes = new Buffer(signature.toDER());
    const signatureLength = (0, exports.uvarint64ToBuf)(signatureBytes.length);
    // If transaction is signed with a derived key, use DeSo-DER recoverable signature encoding.
    if (isDerivedKey) {
        signatureBytes[0] += 1 + signature.recoveryParam;
    }
    const signedTransactionBytes = Buffer.concat([
        // This slice is bad. We need to remove the existing signature length field prior to appending the new one.
        // Once we have frontend transaction construction we won't need to do this.
        transactionBytes.slice(0, -1),
        signatureLength,
        signatureBytes,
    ]);
    return signedTransactionBytes.toString('hex');
};
exports.signTransaction = signTransaction;
const encryptMessage = async (deso, messageToSend, derivedKeyResponse, RecipientPublicKeyBase58Check, groupName = 'default-key') => {
    const { derivedSeedHex, messagingPrivateKey } = derivedKeyResponse;
    const response = await deso.social.checkPartyMessagingKey({
        RecipientMessagingKeyName: groupName,
        RecipientPublicKeyBase58Check,
        SenderMessagingKeyName: groupName,
        SenderPublicKeyBase58Check: deso.identity.getUserKey(),
    });
    if (!messagingPrivateKey) {
        alert('messagingPrivateKey is undefined');
        return;
    }
    const encryptedMessage = encryptMessageFromPrivateMessagingKey(messagingPrivateKey, response.RecipientMessagingPublicKeyBase58Check, messageToSend);
    if (!encryptedMessage) {
        alert('unable to encrypt message');
        return;
    }
    const transaction = await deso.social.sendMessageWithoutIdentity({
        EncryptedMessageText: encryptedMessage.toString('hex'),
        RecipientPublicKeyBase58Check,
        SenderPublicKeyBase58Check: deso.identity.getUserKey(),
        MinFeeRateNanosPerKB: 1000,
        SenderMessagingGroupKeyName: groupName,
        RecipientMessagingGroupKeyName: groupName,
    });
    if (!(transaction === null || transaction === void 0 ? void 0 : transaction.TransactionHex)) {
        alert('failed to construct transaction');
        return;
    }
    const signedTransaction = deso.utils.signTransaction(derivedSeedHex, transaction.TransactionHex, true);
    await deso.transaction.submitTransaction(signedTransaction).catch(() => {
        alert('something went wrong while submitting the transaction');
    });
};
exports.encryptMessage = encryptMessage;
function encryptMessageFromPrivateMessagingKey(privateMessagingKey, recipientPublicKey, message) {
    const privateKey = (0, exports.seedHexToPrivateKey)(privateMessagingKey);
    const groupPrivateEncryptionKeyBuffer = privateKey
        .getPrivate()
        .toBuffer(undefined, 32);
    const publicKeyBuffer = publicKeyToECBuffer(recipientPublicKey);
    return (0, exports.encryptShared)(groupPrivateEncryptionKeyBuffer, publicKeyBuffer, message);
}
exports.encryptMessageFromPrivateMessagingKey = encryptMessageFromPrivateMessagingKey;
function publicKeyToECBuffer(publicKey) {
    const publicKeyEC = publicKeyToECKeyPair(publicKey);
    return new Buffer(publicKeyEC.getPublic('array'));
}
function publicKeyToECKeyPair(publicKey) {
    // Sanity check similar to Base58CheckDecodePrefix from core/lib/base58.go
    if (publicKey.length < 5) {
        throw new Error('Failed to decode public key');
    }
    const decoded = bs58check.decode(publicKey);
    const payload = Uint8Array.from(decoded).slice(3);
    const ec = new elliptic_1.ec('secp256k1');
    return ec.keyFromPublic(payload, 'array');
}
const encryptShared = function (privateKeySender, publicKeyRecipient, msg, opts = {}) {
    opts = opts || {};
    const sharedPx = (0, exports.derive)(privateKeySender, publicKeyRecipient);
    const sharedPrivateKey = (0, exports.kdf)(sharedPx, 32);
    const sharedPublicKey = (0, exports.getPublic)(sharedPrivateKey);
    opts.legacy = false;
    return (0, exports.encrypt)(sharedPublicKey, msg, opts);
};
exports.encryptShared = encryptShared;
const derive = function (privateKeyA, publicKeyB) {
    assert(Buffer.isBuffer(privateKeyA), 'Bad input');
    assert(Buffer.isBuffer(publicKeyB), 'Bad input');
    assert(privateKeyA.length === 32, 'Bad private key');
    assert(publicKeyB.length === 65, 'Bad public key');
    assert(publicKeyB[0] === 4, 'Bad public key');
    const ec = new elliptic_1.ec('secp256k1');
    const keyA = ec.keyFromPrivate(privateKeyA);
    const keyB = ec.keyFromPublic(publicKeyB);
    const Px = keyA.derive(keyB.getPublic()); // BN instance
    return new Buffer(Px.toArray());
};
exports.derive = derive;
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
}
const kdf = function (secret, outputLength) {
    let ctr = 1;
    let written = 0;
    let result = Buffer.from('');
    while (written < outputLength) {
        const ctrs = Buffer.from([ctr >> 24, ctr >> 16, ctr >> 8, ctr]);
        const hashResult = (0, crypto_1.createHash)('sha256')
            .update(Buffer.concat([ctrs, secret]))
            .digest();
        result = Buffer.concat([result, hashResult]);
        written += 32;
        ctr += 1;
    }
    return result;
};
exports.kdf = kdf;
const getPublic = function (privateKey) {
    assert(privateKey.length === 32, 'Bad private key');
    const ec = new elliptic_1.ec('secp256k1');
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return new Buffer(ec.keyFromPrivate(privateKey).getPublic('arr'));
    // return new Buffer(
    //   ec.keyFromPrivate(privateKey).getPublic().encode('array', true)
    // );
};
exports.getPublic = getPublic;
const encrypt = function (publicKeyTo, msg, opts) {
    opts = opts || {};
    const ephemPrivateKey = opts.ephemPrivateKey || (0, crypto_1.randomBytes)(32);
    const ephemPublicKey = (0, exports.getPublic)(ephemPrivateKey);
    const sharedPx = (0, exports.derive)(ephemPrivateKey, publicKeyTo);
    const hash = (0, exports.kdf)(sharedPx, 32);
    const iv = opts.iv || (0, crypto_1.randomBytes)(16);
    const encryptionKey = hash.slice(0, 16);
    // Generate hmac
    const macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();
    let ciphertext;
    if (opts.legacy) {
        ciphertext = aesCtrEncryptLegacy(iv, encryptionKey, msg);
    }
    else {
        ciphertext = aesCtrEncrypt(iv, encryptionKey, msg);
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //@ts-ignore //TODO is this ignore okay?
    const dataToMac = Buffer.from([...iv, ...ciphertext]);
    const HMAC = hmacSha256Sign(macKey, dataToMac);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //@ts-ignore //TODO is this ignore okay?
    return Buffer.from([...ephemPublicKey, ...iv, ...ciphertext, ...HMAC]);
};
exports.encrypt = encrypt;
const aesCtrEncryptLegacy = function (counter, key, data) {
    const cipher = (0, crypto_1.createCipheriv)('aes-128-ctr', key, counter);
    return cipher.update(data).toString();
};
const aesCtrEncrypt = function (counter, key, data) {
    const cipher = (0, crypto_1.createCipheriv)('aes-128-ctr', key, counter);
    const firstChunk = cipher.update(data);
    const secondChunk = cipher.final();
    return Buffer.concat([firstChunk, secondChunk]);
};
function hmacSha256Sign(key, msg) {
    return (0, crypto_1.createHmac)('sha256', key).update(msg).digest();
}
const decryptMessage = async (messages, derivedKeyResponse) => {
    if (Object.keys(messages).length === 0) {
        alert('no messages found');
        return;
    }
    const { messagingPrivateKey } = derivedKeyResponse;
    let v3Messages = {};
    messages.OrderedContactsWithMessages.forEach((m) => {
        v3Messages = {
            ...v3Messages,
            [m.PublicKeyBase58Check]: m.Messages.filter((m) => m.Version === 3 // needed if you're using an old account with v2 or v1 messages
            ).map((m, i) => {
                var _a;
                try {
                    const DecryptedMessage = decryptMessageFromPrivateMessagingKey(messagingPrivateKey, m).toString();
                    return { ...m, DecryptedMessage };
                }
                catch (e) {
                    console.log(m);
                    return {
                        ...m,
                        DecryptedMessage: '',
                        error: (_a = `${e.message} ${m.IsSender}`) !== null && _a !== void 0 ? _a : 'unknown error',
                    };
                }
            }),
        };
    });
    return v3Messages;
};
exports.decryptMessage = decryptMessage;
function decryptMessageFromPrivateMessagingKey(privateMessagingKey, encryptedMessage) {
    const groupPrivateEncryptionKeyBuffer = (0, exports.seedHexToPrivateKey)(privateMessagingKey)
        .getPrivate()
        .toBuffer(undefined, 32);
    const publicEncryptionKey = publicKeyToECBuffer(encryptedMessage.IsSender
        ? encryptedMessage.RecipientMessagingPublicKey
        : encryptedMessage.SenderMessagingPublicKey);
    return (0, exports.decryptShared)(groupPrivateEncryptionKeyBuffer, publicEncryptionKey, Buffer.from(encryptedMessage.EncryptedText, 'hex'));
}
exports.decryptMessageFromPrivateMessagingKey = decryptMessageFromPrivateMessagingKey;
const decryptShared = function (privateKeyRecipient, publicKeySender, encrypted, opts = {}) {
    opts = opts || {};
    const sharedPx = (0, exports.derive)(privateKeyRecipient, publicKeySender);
    const sharedPrivateKey = (0, exports.kdf)(sharedPx, 32);
    opts.legacy = false;
    return (0, exports.decrypt)(sharedPrivateKey, encrypted, opts);
};
exports.decryptShared = decryptShared;
const decrypt = function (privateKey, encrypted, opts) {
    opts = opts || {};
    const metaLength = 1 + 64 + 16 + 32;
    //TODO Nina look here lengths both === the same value so it fails here
    assert(encrypted.length > metaLength, 'Invalid Ciphertext. Data is too small');
    assert(encrypted[0] >= 2 && encrypted[0] <= 4, 'Not valid ciphertext.');
    // deserialize
    const ephemPublicKey = encrypted.slice(0, 65);
    const cipherTextLength = encrypted.length - metaLength;
    const iv = encrypted.slice(65, 65 + 16);
    const cipherAndIv = encrypted.slice(65, 65 + 16 + cipherTextLength);
    const ciphertext = cipherAndIv.slice(16);
    const msgMac = encrypted.slice(65 + 16 + cipherTextLength);
    // check HMAC
    const px = (0, exports.derive)(privateKey, ephemPublicKey);
    const hash = (0, exports.kdf)(px, 32);
    const encryptionKey = hash.slice(0, 16);
    const macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();
    const dataToMac = Buffer.from(cipherAndIv);
    const hmacGood = hmacSha256Sign(macKey, dataToMac);
    assert(hmacGood.equals(msgMac), 'Incorrect MAC');
    // decrypt message
    if (opts.legacy) {
        return aesCtrDecryptLegacy(iv, encryptionKey, ciphertext);
    }
    else {
        return aesCtrDecrypt(iv, encryptionKey, ciphertext);
    }
};
exports.decrypt = decrypt;
const aesCtrDecryptLegacy = function (counter, key, data) {
    const cipher = (0, crypto_1.createDecipheriv)('aes-128-ctr', key, counter);
    return cipher.update(data).toString();
};
const aesCtrDecrypt = function (counter, key, data) {
    const cipher = (0, crypto_1.createDecipheriv)('aes-128-ctr', key, counter);
    const firstChunk = cipher.update(data);
    const secondChunk = cipher.final();
    return Buffer.concat([firstChunk, secondChunk]);
};
//# sourceMappingURL=Utils.js.map