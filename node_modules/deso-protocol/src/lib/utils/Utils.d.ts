/// <reference types="node" />
import { ec as EC } from 'elliptic';
import { ec } from 'elliptic';
import HDNode from 'hdkey';
import Deso from '../../index';
import { DerivedPrivateUserInfo, MessagingGroupResponse } from 'deso-protocol-types';
export declare const uint64ToBufBigEndian: (uint: number) => Buffer;
export declare const uvarint64ToBuf: (uint: number) => Buffer;
export declare const keychainToSeedHex: (keychain: HDNode) => string;
export interface KeyFromSeedHexInput {
    seedHex: string;
}
export declare const generateKeyFromSeedHex: ({ seedHex }: KeyFromSeedHexInput) => EC.KeyPair;
/**
 *
 * @param config determines how to generate the keypair, currently it only supports mnemonic
 * @returns  EC.keypair object
 */
export interface KeyFromMnemonicInput {
    mnemonic: string;
    extraText?: string;
    nonStandard?: boolean;
}
export declare const generateKeyFromSource: ({ mnemonic, extraText, nonStandard, }: KeyFromMnemonicInput) => EC.KeyPair;
export declare const privateKeyToSeedHex: (privateKey: string) => string;
export declare type Network = 'mainnet' | 'testnet';
/**
 * @returns publicKeyBase58Check Base58 encoded public key
 * @returns keyPair object for signing
 * Generates a new derived key
 */
export declare const generateKey: (network?: Network) => Promise<{
    publicKeyBase58Check: string;
    keyPair: ec.KeyPair;
    seedHex: string;
}>;
/**
 *
 * @param transactionHex transaction representation from the construction endpoint
 * @param keyPair EC key object used to sign the transaction
 * @returns signed transaction bytes that can be submitted to the submitTransaction endpoint
 */
export declare const signMessageLocally: ({ transactionHex, keyPair, }: {
    transactionHex: string;
    keyPair: ec.KeyPair;
}) => string;
export declare const PUBLIC_KEY_PREFIXES: {
    mainnet: {
        bitcoin: number[];
        deso: number[];
    };
    testnet: {
        bitcoin: number[];
        deso: number[];
    };
};
export declare const desoAddressToECKeyPair: (publicKey: string) => ec.KeyPair;
export declare const getMetaMaskMasterPublicKeyFromSignature: (signature: string, message: number[], network?: 'mainnet' | 'testnet') => string;
export declare const privateKeyToDeSoPublicKey: (privateKey: ec.KeyPair, network?: Network) => string;
export declare const publicKeyToDeSoPublicKey: (publicKey: EC.KeyPair, network?: Network) => string;
export declare function seedHexToECKeyPair(seedHex: string): EC.KeyPair;
export declare const seedHexToPrivateKey: (seedHex: string) => EC.KeyPair;
export declare const signTransaction: (seedHex: string, transactionHex: string, isDerivedKey: boolean) => string;
export declare const encryptMessage: (deso: Deso, messageToSend: string, derivedKeyResponse: Partial<DerivedPrivateUserInfo>, RecipientPublicKeyBase58Check: string, groupName?: string) => Promise<void>;
export declare function encryptMessageFromPrivateMessagingKey(privateMessagingKey: string, recipientPublicKey: string, message: string): Buffer;
export declare const encryptShared: (privateKeySender: Buffer, publicKeyRecipient: Buffer, msg: string, opts?: {
    iv?: Buffer;
    legacy?: boolean;
    ephemPrivateKey?: Buffer;
}) => Buffer;
export declare const derive: (privateKeyA: Buffer, publicKeyB: Buffer) => Buffer;
export declare const kdf: (secret: Buffer, outputLength: number) => Buffer;
export declare const getPublic: (privateKey: Buffer) => Buffer;
export declare const encrypt: (publicKeyTo: Buffer, msg: string, opts: {
    iv?: Buffer;
    legacy?: boolean;
    ephemPrivateKey?: Buffer;
}) => Buffer;
export declare const decryptMessage: (messages: MessagingGroupResponse, derivedKeyResponse: Partial<DerivedPrivateUserInfo>) => Promise<any>;
export declare function decryptMessageFromPrivateMessagingKey(privateMessagingKey: string, encryptedMessage: any): string | Buffer;
export declare const decryptShared: (privateKeyRecipient: Buffer, publicKeySender: Buffer, encrypted: Buffer, opts?: {
    legacy?: boolean;
}) => string | Buffer;
export declare const decrypt: (privateKey: Buffer, encrypted: Buffer, opts: {
    legacy?: boolean;
}) => string | Buffer;
